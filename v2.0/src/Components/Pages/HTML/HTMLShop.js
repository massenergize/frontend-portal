const {
  HEADER,
  ORDERED,
  LIST,
  PARAGRAPH,
  IMAGE,
  PARA_START,
  PARA_END,
  IMG_START,
  IMG_START_END,
  IMG_END,
  H1,
  H2,
  H3,
  H4,
  H5,
  H6_END,
  H6,
  H1_END,
  H2_END,
  H3_END,
  H4_END,
  H5_END,
  LIST_START,
  LIST_END,
  OL_START,
  OL_END,
  UL_START,
  UL_END,
  SPACE,
  BREAK,
  SMALL_START,
  SMALL_END,
  DOT,
  NEW_EDITOR_IDENTITY,
} = require("./Konstants");

const getURLFromText = (text) => {
  const url = text.split('href="')[1].split('">')[0];
  return url;
};
const href = (url) => {
  return ` href="${url}"`;
};
const src = (url) => {
  return `src="${url}"`;
};
const createImage = (data) => {
  return `<img ${src(data.url)}/>`;
};
const createHead = (url) => {
  return `<a href="${url}" target="_blank">`;
};
const hasLink = (text) => {
  var exploded = text.split("<a");
  return exploded.length > 1 ? true : false; // if there is more than one item in this array, it means there is an anchor tag in the text
};

const makeURLOutbound = (text) => {
  //consider a text like this 'something <a href="www.massenergize.org">Go to massenergize</a>'
  var first = text.split("<a"); //calling .split("<a") on the text, will give an array like this ["something","href="www.massenergize.org">Go to massenergize</a>"]
  var textBeforeHrefStarted = first[0]; //save "something" somewhere
  var second = first[1].split('">'); // calling .split('">') on the second item of first, now gives ["href="www.massenergize.org","Go to massenergize</a>"]
  // at this point, we only care about replacing the beginning head of the <a> tag, so that we can specify target ="_blank"
  //then attach the rest of whatever remaining text there was...
  var textAfterHrefStarted = second[1];
  var url = getURLFromText(text); //this function will extract the url that the admin creator provided from the text, so we can use it to create an new <a> tag head
  var newOutbountAnchorHead = createHead(url);
  var completelyDressedUp = `${textBeforeHrefStarted}${newOutbountAnchorHead}${textAfterHrefStarted}`;
  return completelyDressedUp;
  //  mtseeew, only works for text with one link what of multiple.....
};

const makeSpace = () => {
  return BREAK;
};
const makeLinksOpenNewTab = (text) => {
  var hrefCheckPoints = text.split('<a href="'); // This is constant, all links generated by the editor, are going to start like this
  var howManyLinks = hrefCheckPoints.length - 1;
  var textStartPoint = hrefCheckPoints[0];
  hrefCheckPoints = hrefCheckPoints.slice(1);
  var newString = textStartPoint;
  hrefCheckPoints.forEach((subtext) => {
    var pieces = subtext.split('">');
    var url = pieces[0];
    var newAnchorHead = createHead(url);
    var newPiece = `${newAnchorHead}${pieces[1]}`;
    newString = newString + newPiece;
  });
  return newString;
};
const getHeader = (level, text) => {
  var content;
  switch (level) {
    case 1:
      return (content = `${H1}${text}${H1_END}`);
    case 2:
      return (content = `${H2}${text}${H2_END}`);
    case 3:
      return (content = `${H3}${text}${H3_END}`);
    case 4:
      return (content = `${H4}${text}${H4_END}`);
    case 5:
      return (content = `${H5}${text}${H5_END}`);
    case 6:
      return (content = `${H6}${text}${H6_END}`);

    default:
      return "";
      break;
  }
};
const changingRoom = (block) => {
  var dressedUp, text, containsLinks, toBeSent;
  switch (block.type) {
    case HEADER:
      text = block.data.text;
      var level = block.data.level;
      containsLinks = hasLink(text);
      if (containsLinks) {
        text = makeLinksOpenNewTab(block.data.text);
      }
      dressedUp = getHeader(level, text);
      return { HTML: dressedUp, text: text };
    case LIST:
      var items = block.data.items;
      var together = "";
      items.forEach((item) => {
        text = item;
        containsLinks = hasLink(text);
        if (containsLinks) {
          text = makeLinksOpenNewTab(block.data.text);
        }
        dressedUp = `${LIST_START}${text}${LIST_END}`;
        together = `${together}${dressedUp}`;
      });

      return { HTML: together, text: text };
    case PARAGRAPH:
      text = block.data.text;
      if (
        text.trim().toLowerCase() === SPACE.toLowerCase() ||
        text.trim().toLowerCase() === DOT
      ) {
        return { HTML: makeSpace(), text };
      }
      containsLinks = hasLink(text);
      if (containsLinks) {
        text = makeLinksOpenNewTab(block.data.text);
      }
      dressedUp = `${PARA_START}${text}${PARA_END}`;
      return { HTML: dressedUp, text: text };
    case IMAGE:
      var caption = block.data.caption,
        small = "";
      if (caption) {
        small = `${SMALL_START}${caption}${SMALL_END}`;
      }
      dressedUp = `${IMG_START} ${src(
        block.data.url
      )}${IMG_START_END}${IMG_END}${small}`;
      return { HTML: dressedUp, url: block.data.url };

    default:
      return "";
  }
};
// doesnt have to be async on the portal side (not collecting any async data)
const factory = (blocks) => {
  var HTML = "",
    newBlocks = [];
  if (!blocks) return { HTML, blocks: newBlocks };

  blocks.forEach((block) => {
    var refined = changingRoom(block);
    if (block.type === LIST) {
      var style = block.data.style;
      if (style === ORDERED) {
        refined.HTML = `${OL_START}${refined.HTML}${OL_END}`;
      } else {
        refined.HTML = `${UL_START}${refined.HTML}${UL_END}`;
      }
      HTML = `${HTML}${refined.HTML}`;
      newBlocks.push({ ...block, data: { ...block.data, text: refined.text } });
    } else {
      HTML = `${HTML}${refined.HTML}`;
      newBlocks.push({ ...block, data: { ...block.data, text: refined.text } });
    }
  });
  return { HTML, blocks: newBlocks };
};
const isFromNewEditor = (string) => {
  if (!string) return false;
  const arr = string.split(NEW_EDITOR_IDENTITY);
  const answer = arr.length === 1 ? false : true;
  return answer;
};
export const getHTMLContent = (string) => {
  if (isFromNewEditor(string)) {
    var json = string.split(NEW_EDITOR_IDENTITY)[1];
    json = JSON.parse(json);
    const HTML =  factory(json.blocks).HTML;
    return HTML;
  }
  return string;
};

// export default {
//   hasLink,
//   getURLFromText,
//   makeURLOutbound,
//   makeLinksOpenNewTab,
//   factory,
//   isFromNewEditor,
//   getHTMLContent,
// };
